import*as e from"three";class n extends e.Material{constructor(n){if(!n)throw new Error("Options object must be provided.");n.uniforms||(n.uniforms={}),n.passthrough||(n.passthrough={});const r=new e[n.baseMaterial](n.passthrough);super();for(const e in r)void 0===this[e]&&(this[e]=0);this.setValues(r);const o=/\/\*[\s\S]*?\*\/|\/\/.*/g;this.onBeforeCompile=e=>{var r,s,a,t,l,c;e.vertexShader=i("vert",e.vertexShader,{defines:null===(r=n.vShader.defines)||void 0===r?void 0:r.replace(o,""),header:null===(s=n.vShader.header)||void 0===s?void 0:s.replace(o,""),main:null===(a=n.vShader.main)||void 0===a?void 0:a.replace(o,"")}),n.fShader&&(e.fragmentShader=i("frag",e.fragmentShader,{defines:null===(t=n.fShader.defines)||void 0===t?void 0:t.replace(o,""),header:null===(l=n.fShader.header)||void 0===l?void 0:l.replace(o,""),main:null===(c=n.fShader.main)||void 0===c?void 0:c.replace(o,"")})),e.uniforms=Object.assign(Object.assign({},e.uniforms),n.uniforms),this.uniforms=e.uniforms,this.needsUpdate=!0}}}function i(e,n,i){const{defines:r="",header:o="",main:s=""}=i;let a=n,t=s.includes("csm_Position")?"csm_Position":"position",l=s.includes("csm_Normal")?"csm_Normal":"normal",c=s.includes("csm_DiffuseColor")?"diffuseColor = csm_DiffuseColor":"";s.includes("newPos")&&(t="newPos"),s.includes("newNormal")&&(l="newNormal"),s.includes("newColor")&&(c="diffuseColor = newColor");const d="vert"===e?{"#include <defaultnormal_vertex>":`\n          vec3 transformedNormal = ${l};\n          `,"#include <project_vertex>":`\n          transformed = ${t};\n          #include <project_vertex>\n        `}:{"#include <color_fragment>":`\n          #include <color_fragment>\n          ${c};\n    `};return Object.keys(d).forEach((e=>{var n,i;n=e,i=d[e],a=a.split(n).join(i)})),a=a.replace("void main() {",`\n      ${o}\n      void main() {\n        vec3 csm_Position;\n        vec3 csm_Normal;\n        vec4 csm_DiffuseColor;\n        float csm_PointSize;\n        ${s}\n      `),s.includes("csm_PointSize")&&(a=a.replace("gl_PointSize = size;","gl_PointSize = csm_PointSize;")),`\n      ${r}\n      ${a}\n    `}const r={NORMAL:"MeshNormalMaterial",BASIC:"MeshBasicMaterial",PHONG:"MeshPhongMaterial",MATCAP:"MeshMatcapMaterial",TOON:"MeshToonMaterial",PHYSICAL:"MeshPhysicalMaterial",LAMBERT:"MeshLambertMaterial",DEPTH:"MeshDepthMaterial",POINTS:"PointsMaterial"};export{n as CustomShaderMaterial,r as TYPES};
//# sourceMappingURL=three-csm.m.js.map
